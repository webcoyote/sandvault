#!/usr/bin/env bash
set -Eeuo pipefail
trap 'echo "${BASH_SOURCE[0]}: line $LINENO: $BASH_COMMAND: exitcode $?"' ERR
SCRIPT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"
SCRIPT_NAME="$(basename "${BASH_SOURCE[0]}")"
cd "$SCRIPT_DIR/.."

YELLOW='\033[1;33m'
GRAY='\033[90m'
CYAN='\033[36m'
NC='\033[0m' # No Color

# Set VERBOSE=non-number to VERBOSE=1, otherwise use the number
[[ "${VERBOSE:-0}" =~ ^[0-9]+$ ]] && VERBOSE="${VERBOSE:-0}" || VERBOSE=1

trace () {
    [[ "$VERBOSE" -lt 2 ]] || echo >&2 -e "ðŸ”¬ ${GRAY}$*${NC}"
}
debug () {
    [[ "$VERBOSE" -lt 1 ]] || echo >&2 -e "ðŸ” ${CYAN}$*${NC}"
}

if ! command -v shellcheck &>/dev/null ; then
    echo -e >&2 "${YELLOW}$SCRIPT_NAME: shellcheck not installed; skipping checks${NC}"
    exit 0
fi

# Function to find shell script files
#   ^[^.]+$ - files with no dots (no extension)
#   \.sh$   - files ending with .sh
find_shell_files() {
    local search_path="${1:-.}"
    fd --hidden -t f '(^[^.]+$|\.sh$)' --exclude '.git' -0 "$search_path"
}

FILES=()
if [[ $# -gt 0 ]]; then
    # Use files specified on the command line
    for file in "$@"; do
        if [[ -d "$file" ]]; then
            # Find all matching files in the directory
            while IFS= read -r -d '' found_file; do
                FILES+=("$found_file")
            done < <(find_shell_files "$file")
        else
            FILES+=("$file")
        fi
    done
else
    # Find all the script files in the entire project
    while IFS= read -r -d '' file; do
        FILES+=("$file")
    done < <(find_shell_files)
fi

# Scan all the files
EXITCODE=0
for file in "${FILES[@]}"; do
    # Ignore files that don't have shell-script shebang: "#!...sh"
    if ! awk 'NR==1 && /^#!/ && /sh$/{exit 0} {exit 1}' "$file" ; then
        trace "Skipping $file (not shell script)"
        continue
    fi

    debug "Checking $file"
    shellcheck "$file" || EXITCODE=1
done

exit "$EXITCODE"
