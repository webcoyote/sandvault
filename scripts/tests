#!/usr/bin/env bash
# Test the sv CLI and sandbox security
set -Eeuo pipefail
START_TIME=$(date +%s.%N)

SCRIPT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"
SV="$SCRIPT_DIR/../sv"
HOST_USER="$USER"
HOST_HOME="$HOME"
SANDVAULT_USER="sandvault-$HOST_USER"
SANDVAULT_HOME="/Users/$SANDVAULT_USER"

# Colors
RED='\033[0;31m'
GREEN='\033[0;32m'
NC='\033[0m'

TESTS_RUN=0
TESTS_PASSED=0
TESTS_FAILED=0

pass() {
    ((TESTS_PASSED++)) || true
    echo -e "${GREEN}PASS${NC}: $1"
}

fail() {
    ((TESTS_FAILED++)) || true
    echo -e "${RED}FAIL${NC}: $1"
    [[ -n "${2:-}" ]] && echo "  Expected: $2"
    [[ -n "${3:-}" ]] && echo "  Got: $3"
}

# Run command in sandbox and capture output
sandbox_run() {
    echo "$1 ; exit" | "$SV" s 2>&1 || true
}

# Run command in sandbox via CLI args
sandbox_run_args() {
    "$SV" s -- "$@" 2>&1 || true
}

# Test that sandbox output contains expected string
assert_sandbox_contains() {
    local name="$1"
    local cmd="$2"
    local expected="$3"
    ((TESTS_RUN++)) || true
    local output
    output=$(sandbox_run "$cmd")
    if [[ "$output" == *"$expected"* ]]; then
        pass "$name"
    else
        fail "$name" "contains '$expected'" "$output"
    fi
}

assert_sandbox_args_contains() {
    local name="$1"
    shift
    local expected="${*: -1}"
    local output
    ((TESTS_RUN++)) || true
    output=$(sandbox_run_args "${@:1:$#-1}")
    if [[ "$output" == *"$expected"* ]]; then
        pass "$name"
    else
        fail "$name" "contains '$expected'" "$output"
    fi
}

# Test that sandbox command returns expected exit code
assert_sandbox_exit_code() {
    local name="$1"
    local expected="$2"
    shift 2
    ((TESTS_RUN++)) || true
    local output status
    set +e
    output=$("$SV" s -- "$@" 2>&1)
    status=$?
    set -e
    if [[ "$status" -eq "$expected" ]]; then
        pass "$name"
    else
        fail "$name" "$expected" "$status | $output"
    fi
}

# Test that sandbox output does NOT contain a string
assert_sandbox_not_contains() {
    local name="$1"
    local cmd="$2"
    local forbidden="$3"
    ((TESTS_RUN++)) || true
    local output
    output=$(sandbox_run "$cmd")
    if [[ "$output" != *"$forbidden"* ]]; then
        pass "$name"
    else
        fail "$name" "should not contain '$forbidden'" "$output"
    fi
}

# Test that sandbox command fails (non-zero exit or error output)
assert_sandbox_fails() {
    local name="$1"
    local cmd="$2"
    ((TESTS_RUN++)) || true
    local output
    output=$(sandbox_run "$cmd")
    # Check for common error indicators
    if [[ "$output" == *"denied"* ]] || \
       [[ "$output" == *"Permission denied"* ]] || \
       [[ "$output" == *"Operation not permitted"* ]] || \
       [[ "$output" == *"No such file"* ]] || \
       [[ "$output" == *"not permitted"* ]]; then
        pass "$name"
    else
        fail "$name" "command should fail" "$output"
    fi
}

# Test that PATH order in sandbox is correct
assert_sandbox_path_order() {
    local name="$1"
    local before="$2"
    local after="$3"
    ((TESTS_RUN++)) || true
    local output path pos_before pos_after
    output=$(sandbox_run "printf '%s' \"\$PATH\"")
    output="${output%%$'\n'*}"
    if [[ -z "$output" ]]; then
        fail "$name" "PATH output" "<empty>"
        return
    fi
    path=":$output:"
    pos_before="${path%%:$before:*}"
    pos_after="${path%%:$after:*}"
    if [[ "$pos_before" != "$path" && "$pos_after" != "$path" && ${#pos_before} -lt ${#pos_after} ]]; then
        pass "$name"
    else
        fail "$name" "$before before $after" "$output"
    fi
}

###############################################################################
echo "=== CLI Argument Tests ==="
###############################################################################

# --version
((TESTS_RUN++)) || true
output=$("$SV" --version 2>&1)
if [[ "$output" == *"version"* ]]; then pass "--version shows version"; else fail "--version shows version"; fi

# --help
((TESTS_RUN++)) || true
output=$("$SV" --help 2>&1)
if [[ "$output" == *"Usage:"* ]]; then pass "--help shows usage"; else fail "--help shows usage"; fi

# Unknown option
((TESTS_RUN++)) || true
output=$("$SV" --bogus 2>&1) || true
if [[ "$output" == *"Unknown option"* ]]; then pass "unknown option rejected"; else fail "unknown option rejected"; fi

###############################################################################
echo ""
echo "=== Sandbox Identity Tests ==="
###############################################################################

# Verify we're running as sandvault user, not host user
assert_sandbox_contains "running as sandvault user" "whoami" "$SANDVAULT_USER"

# Verify HOME is sandvault's home (single quotes intentional - evaluated in sandbox)
# shellcheck disable=SC2016
assert_sandbox_contains "HOME is sandvault home" 'echo $HOME' "/Users/sandvault-"
# shellcheck disable=SC2016
assert_sandbox_not_contains "HOME is not host home" 'echo $HOME' "$HOST_HOME"

###############################################################################
echo ""
echo "=== Sandbox PATH Tests ==="
###############################################################################

assert_sandbox_path_order "\$USER/bin precedes /opt/homebrew/bin" "$SANDVAULT_HOME/bin" "/opt/homebrew/bin"

###############################################################################
echo ""
echo "=== Sandbox Escape Tests: Host User Files ==="
###############################################################################

# Cannot read host user's home directory
assert_sandbox_fails "cannot ls host home" "ls $HOST_HOME"
assert_sandbox_fails "cannot read host .zshrc" "cat $HOST_HOME/.zshrc"
assert_sandbox_fails "cannot read host .ssh" "ls $HOST_HOME/.ssh"

# Cannot read other users' directories
assert_sandbox_fails "cannot ls /Users/root" "ls /Users/root"

###############################################################################
echo ""
echo "=== Sandbox Escape Tests: /Volumes (External Drives) ==="
###############################################################################

# sandbox-exec should block /Volumes access (except Macintosh HD)
assert_sandbox_fails "cannot ls /Volumes" "ls /Volumes"
assert_sandbox_fails "cannot read /Volumes" "cat /Volumes/test 2>&1"

###############################################################################
echo ""
echo "=== Sandbox Escape Tests: Sensitive System Files ==="
###############################################################################

# Should not be able to read shadow password file or other sensitive files
assert_sandbox_fails "cannot read /etc/sudoers" "cat /etc/sudoers"
assert_sandbox_fails "cannot read /etc/master.passwd" "cat /etc/master.passwd"

###############################################################################
echo ""
echo "=== Sandbox Allowed Access Tests ==="
###############################################################################

# Should be able to access shared workspace
SHARED_WORKSPACE="/Users/Shared/sv-$HOST_USER"
assert_sandbox_contains "can access shared workspace" "ls $SHARED_WORKSPACE" "SANDVAULT-README"

# Should be able to run basic commands
assert_sandbox_contains "can run echo" "echo hello" "hello"
assert_sandbox_contains "can run pwd" "pwd" "/"

###############################################################################
echo ""
echo "=== Initial Directory Tests ==="
###############################################################################

# Test that unreadable directory falls back to SHARED_WORKSPACE
# Host user's home directory should not be readable by sandvault user
((TESTS_RUN++)) || true
output=$(cd "$HOST_HOME" && echo "pwd ; exit" | "$SV" s 2>&1)
if [[ "$output" == *"$SHARED_WORKSPACE"* ]]; then
    pass "unreadable directory falls back to SHARED_WORKSPACE"
else
    fail "unreadable directory falls back to SHARED_WORKSPACE" "$SHARED_WORKSPACE" "$output"
fi

# Test that readable directory is used as working directory
# /Users is readable by all users
((TESTS_RUN++)) || true
output=$(cd /Users && echo "pwd ; exit" | "$SV" s 2>&1)
if [[ "$output" == *"/Users"* ]]; then
    pass "readable directory is used as working directory"
else
    fail "readable directory is used as working directory" "/Users" "$output"
fi

###############################################################################
echo ""
echo "=== Shell Args Tests ==="
###############################################################################

assert_sandbox_args_contains "sv s -- invalid command errors" "definitely-not-a-command-xyz" "command not found"
assert_sandbox_args_contains "sv s -- printf preserves quoted args" "printf" "%s\\n" "a b" "c d" $'a b\nc d'
assert_sandbox_exit_code "sv s -- exit 33 returns 33" 33 exit 33

###############################################################################
echo ""
echo "=== Summary ==="
###############################################################################

echo "Tests run: $TESTS_RUN"
echo -e "Passed: ${GREEN}$TESTS_PASSED${NC}"
echo -e "Failed: ${RED}$TESTS_FAILED${NC}"

if [[ "$TESTS_FAILED" -gt 0 ]]; then
    exit 1
fi

END_TIME=$(date +%s.%N)
ELAPSED_TIME=$(echo "$END_TIME - $START_TIME" | bc --mathlib | xargs printf "%.2f\n")
echo -e "âœ… Tests completed in $ELAPSED_TIME seconds!"
