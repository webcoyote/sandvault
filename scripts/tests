#!/usr/bin/env bash
# Test the sv CLI and sandbox security
set -Eeuo pipefail
START_TIME=$(date +%s.%N)

SCRIPT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"
SV_BASE="$SCRIPT_DIR/../sv"
HOST_USER="$USER"
HOST_HOME="$HOME"
SANDVAULT_USER="sandvault-$HOST_USER"
SANDVAULT_HOME="/Users/$SANDVAULT_USER"

# Colors
RED='\033[0;31m'
GREEN='\033[0;32m'
NC='\033[0m'

TESTS_RUN=0
TESTS_PASSED=0
TESTS_FAILED=0

pass() {
    ((TESTS_PASSED++)) || true
    echo -e "  ${GREEN}PASS${NC}: $1"
}

fail() {
    ((TESTS_FAILED++)) || true
    echo -e "  ${RED}FAIL${NC}: $1"
    echo "    Expected: ${2:-}"
    echo "    Got: ${3:-}"
}

# Run sv command with current mode
sv_cmd() {
    "${SV_CMD[@]}" "$@"
}

# Run command in sandbox and capture output
sandbox_run() {
    set +e
    echo "$1 ; exit" | sv_cmd s 2>&1
    set -e
}

# Run command in sandbox via CLI args
sandbox_run_args() {
    set +e
    sv_cmd s -- "$@" 2>&1
    set -e
}

# Test that sandbox output contains expected string
assert_sandbox_contains() {
    local name="$1"
    local cmd="$2"
    local expected="$3"
    ((TESTS_RUN++)) || true
    local output
    output=$(sandbox_run "$cmd")
    if [[ "$output" == *"$expected"* ]]; then
        pass "$name"
    else
        fail "$name" "contains '$expected'" "$output"
    fi
}

assert_sandbox_args_contains() {
    local name="$1"
    shift
    local expected="${*: -1}"
    local output
    ((TESTS_RUN++)) || true
    output=$(sandbox_run_args "${@:1:$#-1}")
    if [[ "$output" == *"$expected"* ]]; then
        pass "$name"
    else
        fail "$name" "contains '$expected'" "$output"
    fi
}

# Test that sandbox command returns expected exit code
assert_sandbox_exit_code() {
    local name="$1"
    local expected="$2"
    shift 2
    ((TESTS_RUN++)) || true
    local output status
    set +e
    output=$(sv_cmd s -- "$@" 2>&1)
    status=$?
    set -e
    if [[ "$status" -eq "$expected" ]]; then
        pass "$name"
    else
        fail "$name" "$expected" "$status | $output"
    fi
}

# Test that sandbox output does NOT contain a string
assert_sandbox_not_contains() {
    local name="$1"
    local cmd="$2"
    local forbidden="$3"
    ((TESTS_RUN++)) || true
    local output
    output=$(sandbox_run "$cmd")
    if [[ "$output" != *"$forbidden"* ]]; then
        pass "$name"
    else
        fail "$name" "should not contain '$forbidden'" "$output"
    fi
}

# Test that sandbox command fails (non-zero exit or error output)
assert_sandbox_fails() {
    local name="$1"
    local cmd="$2"
    ((TESTS_RUN++)) || true
    local output
    output=$(sandbox_run "$cmd")
    # Check for common error indicators
    if [[ "$output" == *"denied"* ]] || \
       [[ "$output" == *"Permission denied"* ]] || \
       [[ "$output" == *"Operation not permitted"* ]] || \
       [[ "$output" == *"No such file"* ]] || \
       [[ "$output" == *"not permitted"* ]]; then
        pass "$name"
    else
        fail "$name" "command should fail" "$output"
    fi
}

# Test that PATH order in sandbox is correct
assert_sandbox_path_order() {
    local name="$1"
    local before="$2"
    local after="$3"
    ((TESTS_RUN++)) || true
    local output path pos_before pos_after
    output=$(sandbox_run "printf '%s' \"\$PATH\"")
    output="${output%%$'\n'*}"
    if [[ -z "$output" ]]; then
        fail "$name" "PATH output" "<empty>"
        return
    fi
    path=":$output:"
    pos_before="${path%%:"$before":*}"
    pos_after="${path%%:"$after":*}"
    if [[ "$pos_before" != "$path" && "$pos_after" != "$path" && ${#pos_before} -lt ${#pos_after} ]]; then
        pass "$name"
    else
        fail "$name" "$before before $after" "$output"
    fi
}


###############################################################################
# Setup
###############################################################################
run_tests() {
    local mode_label="$1"
    TESTS_RUN=0
    TESTS_PASSED=0
    TESTS_FAILED=0

    echo "=== MODE: $mode_label ==="

    ###############################################################################
    echo "  === CLI Argument Tests ($mode_label) ==="
    ###############################################################################

    # --version
    ((TESTS_RUN++)) || true
    output=$(sv_cmd --version 2>&1)
    if [[ "$output" == *"version"* ]]; then pass "--version shows version"; else fail "--version shows version"; fi

    # --help
    ((TESTS_RUN++)) || true
    output=$(sv_cmd --help 2>&1)
    if [[ "$output" == *"Usage:"* ]]; then pass "--help shows usage"; else fail "--help shows usage"; fi

    # Unknown option
    ((TESTS_RUN++)) || true
    set +e
    output=$(sv_cmd --bogus 2>&1)
    set -e
    if [[ "$output" == *"Unknown option"* ]]; then pass "unknown option rejected"; else fail "unknown option rejected"; fi

    ###############################################################################
    echo ""
    echo "  === Sandbox Identity Tests ($mode_label) ==="
    ###############################################################################

    # Verify we're running as sandvault user, not host user
    assert_sandbox_contains "running as sandvault user" "whoami" "$SANDVAULT_USER"

    # Verify HOME is sandvault's home (single quotes intentional - evaluated in sandbox)
    # shellcheck disable=SC2016
    assert_sandbox_contains "HOME is sandvault home" 'echo $HOME' "/Users/sandvault-$USER"
    # shellcheck disable=SC2016
    assert_sandbox_not_contains "HOME is not host home" 'echo $HOME' "$HOST_HOME"

    ###############################################################################
    echo ""
    echo "  === Sandbox PATH Tests ($mode_label) ==="
    ###############################################################################

    assert_sandbox_path_order "\$USER/bin precedes /opt/homebrew/bin" "$SANDVAULT_HOME/bin" "/opt/homebrew/bin"

    ###############################################################################
    echo ""
    echo "  === Sandbox Escape Tests: Host User Files ($mode_label) ==="
    ###############################################################################

    # Cannot read host user's home directory
    assert_sandbox_fails "cannot ls host home" "ls $HOST_HOME"
    assert_sandbox_fails "cannot read host .zshrc" "cat $HOST_HOME/.zshrc"
    assert_sandbox_fails "cannot read host .ssh" "ls $HOST_HOME/.ssh"

    # Cannot read other users' directories
    assert_sandbox_fails "cannot ls /Users/root" "ls /Users/root"

    ###############################################################################
    echo ""
    echo "  === Sandbox Escape Tests: /Volumes (External Drives) ($mode_label) ==="
    ###############################################################################

    # sandbox-exec should block /Volumes access (except Macintosh HD)
    assert_sandbox_fails "cannot ls /Volumes" "ls /Volumes"
    assert_sandbox_fails "cannot read /Volumes" "cat /Volumes/test 2>&1"

    ###############################################################################
    echo ""
    echo "  === Sandbox Escape Tests: Sensitive System Files ($mode_label) ==="
    ###############################################################################

    # Should not be able to read shadow password file or other sensitive files
    assert_sandbox_fails "cannot read /etc/sudoers" "cat /etc/sudoers"
    assert_sandbox_fails "cannot read /etc/master.passwd" "cat /etc/master.passwd"

    ###############################################################################
    echo ""
    echo "  === Sandbox Allowed Access Tests ($mode_label) ==="
    ###############################################################################

    # Should be able to access shared workspace
    SHARED_WORKSPACE="/Users/Shared/sv-$HOST_USER"
    assert_sandbox_contains "can access shared workspace" "ls $SHARED_WORKSPACE" "SANDVAULT-README"

    # Should be able to run basic commands
    assert_sandbox_contains "can run echo" "echo hello" "hello"

    pushd /Users &>/dev/null
    assert_sandbox_contains "can run pwd" "pwd" "$PWD"
    pushd &>/dev/null

    ###############################################################################
    echo ""
    echo "  === Initial Directory Tests ($mode_label) ==="
    ###############################################################################

    # Test that unreadable directory falls back to SHARED_WORKSPACE
    # Host user's home directory should not be readable by sandvault user
    ((TESTS_RUN++)) || true
    output=$(cd "$HOST_HOME" && echo "pwd ; exit" | sv_cmd s 2>&1)
    if [[ "$output" == *"$SHARED_WORKSPACE"* ]]; then
        pass "unreadable directory falls back to SHARED_WORKSPACE"
    else
        fail "unreadable directory falls back to SHARED_WORKSPACE" "$SHARED_WORKSPACE" "$output"
    fi

    # Test that readable directory is used as working directory
    # /Users is readable by all users
    ((TESTS_RUN++)) || true
    output=$(cd /Users && echo "pwd ; exit" | sv_cmd s 2>&1)
    if [[ "$output" == *"/Users"* ]]; then
        pass "readable directory is used as working directory"
    else
        fail "readable directory is used as working directory" "/Users" "$output"
    fi

    ###############################################################################
    echo ""
    echo "  === Shell Args Tests ($mode_label) ==="
    ###############################################################################

    assert_sandbox_args_contains "sv s -- invalid command errors" "definitely-not-a-command-xyz" "command not found"
    assert_sandbox_args_contains "sv s -- printf preserves quoted args" "printf" "%s\\n" "a b" "c d" $'a b\nc d'
    assert_sandbox_exit_code "sv s -- exit 33 returns 33" 33 exit 33

    ###############################################################################
    echo ""
    echo "  === Summary ($mode_label) ==="
    ###############################################################################

    echo "Tests run: $TESTS_RUN"
    echo -e "Passed: ${GREEN}$TESTS_PASSED${NC}"
    echo -e "Failed: ${RED}$TESTS_FAILED${NC}"

    if [[ "$TESTS_FAILED" -gt 0 ]]; then
        exit 1
    fi
}

# Ensure that the shell doesn't have sudo permissions
sudo --reset-timestamp

for sv_mode in "ssh" "default" ; do
    if [[ "$sv_mode" == "ssh" ]]; then
        SV_CMD=("$SV_BASE" "--ssh")
        mode_label="sv --ssh"
    else
        SV_CMD=("$SV_BASE")
        mode_label="sv"
    fi

    run_tests "$mode_label"
done

END_TIME=$(date +%s.%N)
ELAPSED_TIME=$(echo "$END_TIME - $START_TIME" | bc --mathlib | xargs printf "%.2f\n")
echo -e "âœ… Tests completed in $ELAPSED_TIME seconds!"
